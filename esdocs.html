<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>E# 完整文档 - 树状导航</title><style>*{margin:0;padding:0;box-sizing:border-box;}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Microsoft YaHei',sans-serif;background-color:#f5f5f5;height:100vh;overflow:hidden;}.container{display:flex;height:100vh;position:relative;}.sidebar{width:350px;background:white;border-right:1px solid #e0e0e0;overflow-y:auto;padding:20px 0;transition:transform 0.3s ease;}.mobile-toggle{display:none;position:fixed;top:15px;left:15px;z-index:1000;background:#1976d2;color:white;border:none;padding:10px 15px;border-radius:4px;cursor:pointer;font-size:18px;}.overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:999;}@media (max-width:768px){.sidebar{position:fixed;top:0;left:0;height:100%;z-index:1001;transform:translateX(-100%);}.sidebar.open{transform:translateX(0);}.mobile-toggle{display:block;}.overlay.show{display:block;}.content{margin-left:0;padding:20px 15px;}}.content{flex:1;background:white;overflow-y:auto;padding:30px;}.tree-item{padding:8px 20px;cursor:pointer;transition:background-color 0.2s;font-size:14px;position:relative;}.tree-item:hover{background-color:#f5f5f5;transform:translateX(2px);transition:all 0.2s ease;}.tree-item.active{background-color:#e3f2fd;color:#1976d2;font-weight:500;border-left:3px solid #1976d2;transform:translateX(0);}.tree-item{transition:all 0.2s ease;}.tree-level-1{padding-left:20px;font-weight:600;color:#333;font-size:15px;}.tree-level-2{padding-left:40px;color:#555;}.tree-level-3{padding-left:60px;color:#666;font-size:13px;}.tree-level-4{padding-left:80px;color:#777;font-size:12px;}.tree-toggle{position:absolute;left:8px;top:50%;transform:translateY(-50%);width:12px;height:12px;line-height:12px;text-align:center;font-size:10px;color:#999;cursor:pointer;}.tree-children{max-height:0;overflow:hidden;transition:max-height 0.2s ease-out;}.tree-children.expanded{max-height:2000px;transition:max-height 0.3s ease-in-out;}.content{flex:1;background:white;overflow-y:auto;padding:30px;position:relative;}.content-section{position:relative;max-width:900px;margin:0 auto 30px auto;padding:0 30px;opacity:0;transform:translateY(100%);filter:blur(8px);transition:transform 0.35s cubic-bezier(0.25,0.46,0.45,0.94),opacity 0.35s cubic-bezier(0.25,0.46,0.45,0.94),filter 0.35s cubic-bezier(0.25,0.46,0.45,0.94);pointer-events:none;display:none;}.content-section.active{opacity:1;transform:translateY(0);filter:blur(0px);pointer-events:auto;display:block;}.content-section.slide-up{transform:translateY(-100%);filter:blur(8px);}.content-section.slide-down{transform:translateY(100%);filter:blur(8px);}h1,h2,h3,h4,h5{color:#2c3e50;margin-bottom:20px;}h1{font-size:28px;border-bottom:2px solid #3498db;padding-bottom:10px;}h2{font-size:22px;margin-top:30px;color:#34495e;}h3{font-size:18px;margin-top:25px;color:#2c3e50;}h4{font-size:16px;margin-top:20px;color:#34495e;}pre{background:#f8f9fa;border:1px solid #e9ecef;border-radius:4px;padding:15px;overflow-x:auto;font-size:14px;margin:15px 0;border-left:4px solid #3498db;}code{background:#f8f9fa;padding:2px 6px;border-radius:3px;font-family:'Consolas','Monaco','Courier New',monospace;font-size:14px;color:#d73a49;}.syntax-section{margin-bottom:25px;padding:20px;background:#f8f9fa;border-radius:5px;border-left:3px solid #28a745;}.warning-section{margin-bottom:25px;padding:20px;background:#fff3cd;border-radius:5px;border-left:3px solid #ffc107;}.danger-section{margin-bottom:25px;padding:20px;background:#f8d7da;border-radius:5px;border-left:3px solid #dc3545;}.info-section{margin-bottom:25px;padding:20px;background:#d1ecf1;border-radius:5px;border-left:3px solid #17a2b8;}ul,ol{margin-left:20px;margin-bottom:15px;}li{margin-bottom:8px;}table{border-collapse:collapse;width:100%;margin:15px 0;}th,td{border:1px solid #ddd;padding:12px;text-align:left;}th{background-color:#f2f2f2;font-weight:bold;}.sidebar-header{padding:0 20px 20px 20px;border-bottom:1px solid #e0e0e0;margin-bottom:10px;}.sidebar-header h3{font-size:18px;color:#333;margin:0;}.navigation-buttons{position:fixed;bottom:20px;right:20px;display:flex;gap:10px;z-index:1000;}.nav-btn{padding:10px 20px;background:#1976d2;color:white;border:none;border-radius:20px;cursor:pointer;font-size:14px;transition:all 0.3s ease;box-shadow:0 2px 5px rgba(0,0,0,0.2);}.nav-btn:hover:not(:disabled){background:#1565c0;transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,0.3);}.nav-btn:disabled{background:#ccc;cursor:not-allowed;opacity:0.6;}</style></head><body><div class="container"><div class="sidebar"><div class="sidebar-header"><h3>E# 完整文档导航</h3></div><div class="tree-item tree-level-1" data-target="overview">📋 语言概述</div><div class="tree-item tree-level-1 tree-parent" data-toggle="structure"><span class="tree-toggle">▶</span>🏗️ 程序结构</div><div class="tree-children" id="structure-children"><div class="tree-item tree-level-2" data-target="namespace">命名空间</div><div class="tree-item tree-level-2" data-target="class">类定义</div><div class="tree-item tree-level-2" data-target="main">主方法</div><div class="tree-item tree-level-2" data-target="sections">段定义</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="types"><span class="tree-toggle">▶</span>🔢 数据类型</div><div class="tree-children" id="types-children"><div class="tree-item tree-level-2" data-target="basic-types">基本类型</div><div class="tree-item tree-level-2" data-target="advanced-types">高级类型</div><div class="tree-item tree-level-2" data-target="string-type">字符串</div><div class="tree-item tree-level-2" data-target="bool-type">布尔值</div><div class="tree-item tree-level-2" data-target="ptr-type">指针类型</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="variables"><span class="tree-toggle">▶</span>📝 变量声明</div><div class="tree-children" id="variables-children"><div class="tree-item tree-level-2" data-target="var-int">整数变量</div><div class="tree-item tree-level-2" data-target="var-string">字符串变量</div><div class="tree-item tree-level-2" data-target="var-double">浮点变量</div><div class="tree-item tree-level-2" data-target="var-bool">布尔变量</div><div class="tree-item tree-level-2" data-target="var-ptr">指针变量</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="functions"><span class="tree-toggle">▶</span>⚙️ 函数定义</div><div class="tree-children" id="functions-children"><div class="tree-item tree-level-2" data-target="func-basic">基本函数</div><div class="tree-item tree-level-2" data-target="func-asm">汇编函数</div><div class="tree-item tree-level-2" data-target="func-template">模板函数</div><div class="tree-item tree-level-2" data-target="lambda">Lambda表达式</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="console"><span class="tree-toggle">▶</span>🖥️ 控制台输出</div><div class="tree-children" id="console-children"><div class="tree-item tree-level-2" data-target="writeline">WriteLine</div><div class="tree-item tree-level-2" data-target="write">Write</div><div class="tree-item tree-level-2" data-target="format">格式化输出</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="control"><span class="tree-toggle">▶</span>🔄 控制语句</div><div class="tree-children" id="control-children"><div class="tree-item tree-level-2 tree-parent" data-toggle="if"><span class="tree-toggle">▶</span>条件语句</div><div class="tree-children" id="if-children"><div class="tree-item tree-level-3" data-target="if-basic">基本if</div><div class="tree-item tree-level-3" data-target="if-else">if-else</div><div class="tree-item tree-level-3" data-target="if-elseif">多重条件</div></div><div class="tree-item tree-level-2 tree-parent" data-toggle="loops"><span class="tree-toggle">▶</span>循环语句</div><div class="tree-children" id="loops-children"><div class="tree-item tree-level-3" data-target="for-loop">for循环</div><div class="tree-item tree-level-3" data-target="while-loop">while循环</div><div class="tree-item tree-level-3" data-target="do-while">do-while循环</div></div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="memory"><span class="tree-toggle">▶</span>🧠 内存安全</div><div class="tree-children" id="memory-children"><div class="tree-item tree-level-2" data-target="memory-overview">安全概述</div><div class="tree-item tree-level-2" data-target="memory-boundaries">边界检查</div><div class="tree-item tree-level-2" data-target="memory-null">空指针保护</div><div class="tree-item tree-level-2" data-target="memory-management">自动管理</div><div class="tree-item tree-level-2" data-target="memory-leaks">泄漏防护</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="advanced"><span class="tree-toggle">▶</span>🚀 高级特性</div><div class="tree-children" id="advanced-children"><div class="tree-item tree-level-2" data-target="arrays">数组和集合</div><div class="tree-item tree-level-2" data-target="structs">结构体和类</div><div class="tree-item tree-level-2" data-target="generics">泛型和模板</div><div class="tree-item tree-level-2" data-target="exceptions">异常处理</div><div class="tree-item tree-level-2" data-target="concurrency">并发支持</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="assembly"><span class="tree-toggle">▶</span>🔧 内联汇编</div><div class="tree-children" id="assembly-children"><div class="tree-item tree-level-2" data-target="asm-basic">基本汇编</div><div class="tree-item tree-level-2" data-target="asm-volatile">Volatile汇编</div><div class="tree-item tree-level-2" data-target="asm-examples">实例</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="examples"><span class="tree-toggle">▶</span>📚 示例程序</div><div class="tree-children" id="examples-children"><div class="tree-item tree-level-2" data-target="hello-world">Hello World</div><div class="tree-item tree-level-2" data-target="fibonacci">斐波那契</div><div class="tree-item tree-level-2" data-target="memory-safe-example">内存安全示例</div><div class="tree-item tree-level-2" data-target="system-calls">系统调用</div></div><div class="tree-item tree-level-1 tree-parent" data-toggle="stdlib"><span class="tree-toggle">▶</span>📦 标准库</div><div class="tree-children" id="stdlib-children"><div class="tree-item tree-level-2" data-target="stdlib-memory">内存管理</div><div class="tree-item tree-level-2" data-target="stdlib-string">字符串操作</div><div class="tree-item tree-level-2" data-target="stdlib-io">输入输出</div></div></div><div class="content"><div class="content-section active" id="overview"><h1>E# 语言完整概述</h1><p>E# 是一种语法类似C#的低级汇编语言，设计用于系统编程和底层开发。它结合了C#的高级语法糖和x86/x64汇编的底层控制能力，同时提供完整的内存安全保护。</p><div class="syntax-section"><h2>🌟 主要特点</h2><ul><li><strong>简洁语法</strong>：类似C#的高级语法，易于学习</li><li><strong>底层控制</strong>：支持x86/x64汇编指令和内联汇编</li><li><strong>内存安全</strong>：边界检查、空指针保护、自动内存管理</li><li><strong>跨平台</strong>：支持Linux、Windows、未来支持ARM64</li><li><strong>丰富标准库</strong>：内存管理、字符串操作、文件IO</li><li><strong>现代特性</strong>：泛型、Lambda、异常处理、并发</li></ul></div><div class="syntax-section"><h2>🏗️ 语言架构</h2><p>E# 提供两种编程模式：</p><ul><li><strong>高级模式</strong>：类似C#的面向对象编程</li><li><strong>低级模式</strong>：直接汇编编程，系统级开发</li></ul></div><div class="syntax-section"><h2>🚀 第一个程序</h2><h3>高级C#风格</h3><pre><code>namespace HelloWorld;class Program{void Main(){Console.WriteLine("Hello, World!");}}</code></pre><h3>低级汇编风格</h3><pre><code>section .datamsg: db "Hello from E#!", 0xAlen: equ $ - msgsection .textglobal _startfunction void _start() asm {mov rax, 1 ; sys_writemov rdi, 1 ; stdoutmov rsi, msg ; 消息地址mov rdx, len ; 消息长度syscallmov rax, 60 ; sys_exitxor rdi, rdi ; 状态码0syscall}</code></pre></div></div><div class="content-section" id="namespace"><h1>命名空间</h1><p>命名空间用于组织代码，每个E#程序都必须有命名空间。</p><div class="syntax-section"><h2>基本语法</h2><pre><code>namespace 程序名称;// 代码内容</code></pre></div><div class="syntax-section"><h2>嵌套命名空间</h2><pre><code>namespace MyApp.Utils {class StringHelper {// 实现...}}</code></pre></div></div><div class="content-section" id="class"><h1>类定义</h1><p>类是E#程序的基本组织单位，支持继承、多态等面向对象特性。</p><div class="syntax-section"><h2>基本类定义</h2><pre><code>class Calculator {private int result;public Calculator() {result = 0;}public int add(int a, int b) {result = a + b;return result;}}</code></pre></div><div class="syntax-section"><h2>继承示例</h2><pre><code>class Animal {protected string name;public Animal(string n) {name = n;}virtual public void speak() {Console.WriteLine(name + " makes a sound");}}class Dog extends Animal {public Dog(string n) : Animal(n) {}override public void speak() {Console.WriteLine(name + " barks");}}</code></pre></div></div><div class="content-section" id="main"><h1>主方法</h1><p>主方法是程序的入口点，程序从这里开始执行。</p><div class="syntax-section"><h2>高级模式主方法</h2><pre><code>class Program {void Main() {// 程序入口点Console.WriteLine("程序开始执行");}}</code></pre></div><div class="syntax-section"><h2>低级模式入口点</h2><pre><code>section .textglobal _startfunction void _start() asm {// 程序入口点// 系统调用等底层操作}</code></pre></div></div><div class="content-section" id="sections"><h1>段定义</h1><p>在低级模式中，使用段来组织程序的不同部分。</p><div class="syntax-section"><h2>标准段</h2><pre><code>section .data// 初始化的数据message: db "Hello", 0counter: dd 0section .bss// 未初始化的数据buffer: resb 1024section .textglobal _start// 代码段</code></pre></div></div><div class="content-section" id="basic-types"><h1>基本数据类型</h1><p>E# 支持丰富的数据类型，从8位到64位，有符号和无符号。</p><div class="syntax-section"><h2>整数类型</h2><table><tr><th>类型</th><th>描述</th><th>大小</th><th>范围</th></tr><tr><td><code>int8</code></td><td>8位有符号整数</td><td>1字节</td><td>-128 到 127</td></tr><tr><td><code>int16</code></td><td>16位有符号整数</td><td>2字节</td><td>-32,768 到 32,767</td></tr><tr><td><code>int32</code></td><td>32位有符号整数</td><td>4字节</td><td>-2.1e9 到 2.1e9</td></tr><tr><td><code>int64</code></td><td>64位有符号整数</td><td>8字节</td><td>-9.2e18 到 9.2e18</td></tr><tr><td><code>uint8</code></td><td>8位无符号整数</td><td>1字节</td><td>0 到 255</td></tr><tr><td><code>uint16</code></td><td>16位无符号整数</td><td>2字节</td><td>0 到 65,535</td></tr><tr><td><code>uint32</code></td><td>32位无符号整数</td><td>4字节</td><td>0 到 4.2e9</td></tr><tr><td><code>uint64</code></td><td>64位无符号整数</td><td>8字节</td><td>0 到 1.8e19</td></tr></table></div><div class="syntax-section"><h2>浮点类型</h2><table><tr><th>类型</th><th>描述</th><th>大小</th><th>精度</th></tr><tr><td><code>float32</code></td><td>32位浮点数</td><td>4字节</td><td>~7位十进制</td></tr><tr><td><code>float64</code></td><td>64位浮点数</td><td>8字节</td><td>~15位十进制</td></tr></table></div></div><div class="content-section" id="advanced-types"><h1>高级数据类型</h1><div class="syntax-section"><h2>指针类型</h2><pre><code>int32* ptr; // 指向int32的指针int32** double_ptr; // 双重指针void* generic_ptr; // 通用指针</code></pre></div><div class="syntax-section"><h2>数组类型</h2><pre><code>int32 numbers[10]; // 固定大小数组int32 dynamic[]; // 动态数组int32 matrix[3][3]; // 多维数组</code></pre></div></div><div class="content-section" id="string-type"><h1>字符串类型</h1><p>E# 提供安全且功能丰富的字符串操作。</p><div class="syntax-section"><h2>字符串声明</h2><pre><code>string greeting = "Hello, E#!";string empty = "";string path = "C:\\Program Files\\E#";</code></pre></div><div class="syntax-section"><h2>字符串操作</h2><pre><code>string name = "World";string message = "Hello, " + name;int length = message.length();string upper = message.to_upper();bool contains = message.contains("Hello");</code></pre></div></div><div class="content-section" id="bool-type"><h1>布尔类型</h1><p>布尔类型用于逻辑判断，只有true和false两个值。</p><div class="syntax-section"><h2>基本用法</h2><pre><code>bool isActive = true;bool isCompleted = false;bool result = (5 >3); // true</code></pre></div></div><div class="content-section" id="ptr-type"><h1>指针类型</h1><p>指针提供直接的内存访问能力，E#提供安全的指针操作。</p><div class="syntax-section"><h2>安全指针使用</h2><pre><code>int32* ptr = new int32(42);if (!ptr.is_null()) {int32 value = *ptr;*ptr = 100;}delete ptr;</code></pre></div><div class="syntax-section"><h2>智能指针</h2><pre><code>unique_ptr<int32>smart_ptr = make_unique<int32>(42);shared_ptr<string>shared_str = make_shared<string>("Hello");</code></pre></div></div><div class="content-section" id="var-int"><h1>整数变量</h1><p>整数变量用于存储整数值，支持各种位宽。</p><div class="syntax-section"><h2>整数变量声明</h2><pre><code>int32 age = 25;uint64 big_number = 9223372036854775807;int8 small = -128;uint16 medium = 65535;</code></pre></div><div class="syntax-section"><h2>不同进制表示</h2><pre><code>int32 decimal = 42;int32 hex = 0x2A;int32 binary = 0b101010;int32 octal = 0o52;</code></pre></div></div><div class="content-section" id="var-string"><h1>字符串变量</h1><p>字符串变量用于存储文本数据。</p><div class="syntax-section"><h2>字符串变量声明</h2><pre><code>string name = "张三";string message = "欢迎使用E#";string empty = "";string unicode = "你好 🌍";</code></pre></div><div class="syntax-section"><h2>字符串格式化</h2><pre><code>int32 age = 25;string info = "姓名：张三，年龄：" + age;string formatted = string.format("姓名：{0}，年龄：{1}", "张三", age);</code></pre></div></div><div class="content-section" id="var-double"><h1>浮点变量</h1><p>浮点变量用于存储小数和实数。</p><div class="syntax-section"><h2>浮点变量声明</h2><pre><code>float32 pi = 3.14159f;float64 precise = 3.141592653589793;float32 temperature = -273.15f;float64 price = 99.99;</code></pre></div></div><div class="content-section" id="var-bool"><h1>布尔变量</h1><p>布尔变量用于逻辑判断。</p><div class="syntax-section"><h2>布尔变量声明</h2><pre><code>bool is_valid = true;bool is_empty = false;bool is_greater = (10 >5); // true</code></pre></div></div><div class="content-section" id="var-ptr"><h1>指针变量</h1><p>指针变量存储内存地址。</p><div class="syntax-section"><h2>指针变量声明</h2><pre><code>int32* ptr = new int32(42);uint64* big_ptr = new uint64(1000000);void* generic = nullptr;</code></pre></div></div><div class="content-section" id="func-basic"><h1>基本函数定义</h1><p>函数是代码重用的基本单位。</p><div class="syntax-section"><h2>标准函数</h2><pre><code>function int add(int a, int b) {return a + b;}function void greet(string name) {Console.WriteLine("Hello, " + name);}</code></pre></div></div><div class="content-section" id="func-asm"><h1>汇编函数定义</h1><p>汇编函数直接生成机器码，提供最大性能。</p><div class="syntax-section"><h2>汇编函数</h2><pre><code>function int multiply(int a, int b) asm {mov eax, [a]imul eax, [b]ret}</code></pre></div></div><div class="content-section" id="func-template"><h1>模板函数</h1><p>模板函数支持泛型编程。</p><div class="syntax-section"><h2>泛型函数</h2><pre><code>template<T>function T max(T a, T b) {return (a >b) ? a : b;}// 使用int result = max(10, 20); // 20double dresult = max(3.14, 2.71); // 3.14</code></pre></div></div><div class="content-section" id="lambda"><h1>Lambda表达式</h1><p>Lambda表达式提供简洁的函数定义方式。</p><div class="syntax-section"><h2>Lambda定义</h2><pre><code>auto add = (int x, int y) ->int { return x + y; };auto is_even = (int x) ->bool { return x % 2 == 0; };// 使用int sum = add(5, 3); // 8bool check = is_even(4); // true</code></pre></div></div><div class="content-section" id="writeline"><h1>Console.WriteLine</h1><p>输出文本并换行。</p><div class="syntax-section"><h2>基本用法</h2><pre><code>Console.WriteLine("Hello, World!");Console.WriteLine("当前数字: " + count);Console.WriteLine("姓名: " + name);Console.WriteLine("结果: {0}", result);</code></pre></div></div><div class="content-section" id="write"><h1>Console.Write</h1><p>输出文本但不换行。</p><div class="syntax-section"><h2>基本用法</h2><pre><code>Console.Write("请输入: ");Console.Write("进度: " + percent + "%");Console.Write("处理中");Console.Write(".");</code></pre></div></div><div class="content-section" id="format"><h1>格式化输出</h1><p>支持复杂的格式化输出。</p><div class="syntax-section"><h2>格式化字符串</h2><pre><code>int age = 25;double score = 95.5;string name = "张三";Console.WriteLine("姓名: {0}, 年龄: {1}, 分数: {2:F2}", name, age, score);Console.WriteLine("十六进制: {0:X}", 255); // FFConsole.WriteLine("货币: {0:C}", 1234.56); // ¥1,234.56</code></pre></div></div><div class="content-section" id="for-loop"><h1>for循环</h1><p>用于重复执行代码块。</p><div class="syntax-section"><h2>基本for循环</h2><pre><code>// 基本for循环for (int i = 0; i< 10; i++) {Console.WriteLine("数字: " + i);}// 倒序循环for (int i = 10; i >0; i--) {Console.WriteLine("倒计时: " + i);}// 遍历数组int[] numbers = {1, 2, 3, 4, 5};for (int i = 0; i< numbers.length; i++) {Console.WriteLine(numbers[i]);}</code></pre></div></div><div class="content-section" id="while-loop"><h1>while循环</h1><p>条件为真时重复执行。</p><div class="syntax-section"><h2>基本while循环</h2><pre><code>int count = 0;while (count< 5) {Console.WriteLine("计数: " + count);count++;}// 无限循环while (true) {string input = Console.ReadLine();if (input == "exit") break;}</code></pre></div></div><div class="content-section" id="do-while"><h1>do-while循环</h1><p>至少执行一次，然后检查条件。</p><div class="syntax-section"><h2>基本do-while循环</h2><pre><code>int choice;do {Console.WriteLine("请选择: 1.继续 2.退出");choice = int.parse(Console.ReadLine());} while (choice != 2);</code></pre></div></div><div class="content-section" id="if-basic"><h1>基本if语句</h1><p>条件执行代码块。</p><div class="syntax-section"><h2>基本if</h2><pre><code>int age = 18;if (age >= 18) {Console.WriteLine("成年人");}</code></pre></div></div><div class="content-section" id="if-else"><h1>if-else语句</h1><p>条件为假时执行else块。</p><div class="syntax-section"><h2>if-else</h2><pre><code>int score = 85;if (score >= 60) {Console.WriteLine("及格");} else {Console.WriteLine("不及格");}</code></pre></div></div><div class="content-section" id="if-elseif"><h1>多重条件语句</h1><p>多个条件判断。</p><div class="syntax-section"><h2>if-else if-else</h2><pre><code>int grade = 85;if (grade >= 90) {Console.WriteLine("优秀");} else if (grade >= 80) {Console.WriteLine("良好");} else if (grade >= 70) {Console.WriteLine("中等");} else if (grade >= 60) {Console.WriteLine("及格");} else {Console.WriteLine("不及格");}</code></pre></div></div><div class="content-section" id="memory-overview"><h1>内存安全概述</h1><p>E# 提供多层内存安全保护，从编译时检查到运行时防护，确保程序不会出现内存泄漏、缓冲区溢出、悬垂指针等问题。</p><div class="info-section"><h2>🛡️ 安全特性总览</h2><ul><li><strong>边界检查数组访问</strong>：自动防止缓冲区溢出</li><li><strong>空指针保护</strong>：运行时空指针检查</li><li><strong>自动内存管理</strong>：智能指针和垃圾回收</li><li><strong>内存泄漏防护</strong>：RAII和自动清理</li><li><strong>悬垂指针防护</strong>：所有权系统和生命周期检查</li></ul></div></div><div class="content-section" id="memory-boundaries"><h1>边界检查</h1><p>E# 自动进行数组边界检查，防止缓冲区溢出攻击。</p><div class="syntax-section"><h2>安全数组访问</h2><pre><code>// 安全数组访问int[] arr = new int[10];int val = arr[5]; // 自动边界检查// arr[15] = 42; // 运行时抛出 IndexOutOfBoundsException// 安全边界检查function int safe_get(int[] array, int index) {if (index< 0 || index >= array.length) {throw IndexOutOfBoundsException("数组索引越界");}return array[index];}</code></pre></div><div class="syntax-section"><h2>安全容器</h2><pre><code>// 使用安全容器safe_array<int>numbers = safe_array<int>(100);numbers.add(42);int value = numbers.get(0); // 自动边界检查safe_string text = "Hello World";char c = text[5]; // 安全访问，不会溢出</code></pre></div></div><div class="content-section" id="memory-null"><h1>空指针保护</h1><p>E# 提供运行时空指针检查，防止空指针异常。</p><div class="syntax-section"><h2>空安全操作符</h2><pre><code>// 空安全操作符string str = get_string();int len = str?.length() ?? 0; // 空安全操作符// 强制非空类型string! non_null = "hello"; // 编译时保证非空string? nullable = null; // 可为空类型</code></pre></div><div class="syntax-section"><h2>智能指针空检查</h2><pre><code>unique_ptr<int>ptr = make_unique<int>(42);if (!ptr.is_null()) {int value = *ptr;Console.WriteLine("值: " + value);}// 自动空指针检查// *nullptr; // 抛出 NullPointerException</code></pre></div></div><div class="content-section" id="memory-management"><h1>自动内存管理</h1><p>E# 结合智能指针、垃圾回收和RAII模式，实现自动内存管理。</p><div class="syntax-section"><h2>智能指针</h2><pre><code>// 唯一所有权unique_ptr<int>unique = make_unique<int>(42);shared_ptr<string>shared = make_shared<string>("Hello");// 自动垃圾回收auto ptr = gc_new int[1000]; // 自动回收auto obj = gc_new MyClass(); // 自动析构</code></pre></div><div class="syntax-section"><h2>内存池管理</h2><pre><code>// 内存池管理MemoryPool pool(1024 * 1024); // 1MB内存池auto data = pool.allocate<int>(100);// 自动回收，无需手动释放// RAII模式class Resource {~Resource() { // 自动析构函数cleanup();}};</code></pre></div></div><div class="content-section" id="memory-leaks"><h1>内存泄漏防护</h1><p>E# 提供多种机制防止内存泄漏。</p><div class="syntax-section"><h2>泄漏检测</h2><pre><code>// 内存调试器MemoryDebugger::enable();int* ptr = new int[100];// 如果ptr在作用域结束时未释放，报告泄漏// 内存追踪memory_tracker {auto buffer = new int[1000];// 自动检测泄漏}// 实时统计MemoryStats stats = Memory::get_stats();Console.WriteLine("活跃分配: " + stats.active_allocations);</code></pre></div><div class="syntax-section"><h2>对象池</h2><pre><code>// 对象池自动管理ObjectPool<MyClass>object_pool;auto obj = object_pool.acquire();// 自动归还到对象池，防止泄漏</code></pre></div></div><div class="content-section" id="arrays"><h1>数组和集合</h1><p>E# 提供丰富的数组和集合操作功能。</p><div class="syntax-section"><h2>数组声明和初始化</h2><pre><code>// 数组声明和初始化int numbers[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};string names[] = {"Alice", "Bob", "Charlie"};float matrix[3][3] = {{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}};// 动态数组int* dynamic_array = new int[100];delete[] dynamic_array;</code></pre></div><div class="syntax-section"><h2>高级集合操作</h2><pre><code>// 安全数组操作safe_array<int>arr = safe_array<int>();arr.add(1);arr.add(2);arr.add(3);int size = arr.size();int sum = arr.sum();arr.sort();int index = arr.find(42);// 列表和字典List<string>list = new List<string>();Dictionary<string, int>dict = new Dictionary<string, int>();dict["key"] = 42;</code></pre></div></div><div class="content-section" id="structs"><h1>结构体和类</h1><p>E# 支持结构体和类的定义，支持面向对象编程。</p><div class="syntax-section"><h2>结构体定义</h2><pre><code>// 结构体定义struct Point3D {float x, y, z;function float distance_to(Point3D other) {float dx = x - other.x;float dy = y - other.y;float dz = z - other.z;return sqrt(dx*dx + dy*dy + dz*dz);}};// 使用Point3D p1 = {1.0, 2.0, 3.0};Point3D p2 = {4.0, 5.0, 6.0};float distance = p1.distance_to(p2);</code></pre></div></div><div class="content-section" id="generics"><h1>泛型和模板</h1><p>支持泛型编程，编写可重用的代码。</p><div class="syntax-section"><h2>泛型类</h2><pre><code>// 泛型类class List<T>{private T* data;private int size;private int capacity;public List() {capacity = 10;size = 0;data = new T[capacity];}public void add(T item) {if (size >= capacity) {resize();}data[size++] = item;}public T get(int index) {if (index< 0 || index >= size) {throw IndexOutOfRangeException();}return data[index];}};// 使用List<int>int_list = new List<int>();List<string>str_list = new List<string>();</code></pre></div></div><div class="content-section" id="exceptions"><h1>异常处理</h1><p>E# 提供完整的异常处理机制。</p><div class="syntax-section"><h2>异常处理语法</h2><pre><code>try {int* data = new int[1000000];if (data == null) {throw MemoryAllocationException("内存分配失败");}int result = divide(10, user_input);} catch (DivisionByZeroException e) {Console.WriteLine("错误：除数不能为零");log_error(e.what());} catch (MemoryAllocationException e) {Console.WriteLine("错误：内存不足");cleanup_resources();} catch (...) {Console.WriteLine("未知错误发生");} finally {cleanup();}</code></pre></div></div><div class="content-section" id="concurrency"><h1>并发支持</h1><p>E# 支持多线程和并发编程。</p><div class="syntax-section"><h2>线程创建</h2><pre><code>// 线程 hread worker = create_thread(function void() {for (int i = 0; i< 100; i++) {Console.WriteLine("工作中: " + i);}});// 互斥锁mutex data_mutex;int shared_data = 0;function void safe_increment() {lock(data_mutex) {shared_data++;}}// 原子操作atomic<int>counter = 0;function void increment_counter() {counter.fetch_add(1);}// 异步编程async function int async_task() {await sleep(1000);return 42;}</code></pre></div></div><div class="content-section" id="asm-basic"><h1>基本内联汇编</h1><p>E# 支持内联汇编，提供底层硬件控制。</p><div class="syntax-section"><h2>基本汇编块</h2><pre><code>asm {mov eax, 1add eax, ebxmov [result], eax}// 带参数的汇编function int add_asm(int a, int b) asm {mov eax, [a]add eax, [b]ret}</code></pre></div></div><div class="content-section" id="asm-volatile"><h1>Volatile汇编</h1><p>防止编译器优化的汇编代码。</p><div class="syntax-section"><h2>Volatile汇编</h2><pre><code>asm volatile {cli // 禁用中断hlt // 停机}asm volatile {in al, dx // IO端口读取out dx, al // IO端口写入}</code></pre></div></div><div class="content-section" id="asm-examples"><h1>汇编实例</h1><p>实际汇编编程示例。</p><div class="syntax-section"><h2>系统调用示例</h2><pre><code>// Linux系统调用 - 写入文件function void write_file(string filename, string content) asm {mov rax, 2 // sys_openmov rdi, filename // 文件名mov rsi, 1 // O_WRONLYmov rdx, 0o644 // 权限syscallmov r8, rax // 保存文件描述符mov rax, 1 // sys_writemov rdi, r8 // 文件描述符mov rsi, content // 内容mov rdx, length // 长度syscallmov rax, 3 // sys_closemov rdi, r8syscall}</code></pre></div></div><div class="content-section" id="hello-world"><h1>Hello World示例</h1><p>多种方式的Hello World程序。</p><div class="syntax-section"><h2>高级C#风格</h2><pre><code>namespace HelloWorld;class Program {void Main() {Console.WriteLine("Hello, World from E#!");}}</code></pre></div><div class="syntax-section"><h2>Linux汇编风格</h2><pre><code>section .datamsg: db "Hello from E# assembly!", 0xAlen: equ $ - msgsection .textglobal _startfunction void _start() asm {mov rax, 1 // sys_writemov rdi, 1 // stdoutmov rsi, msg // 消息mov rdx, len // 长度syscallmov rax, 60 // sys_exitxor rdi, rdi // 状态码0syscall}</code></pre></div></div><div class="content-section" id="fibonacci"><h1>斐波那契示例</h1><p>计算斐波那契数列的多种实现。</p><div class="syntax-section"><h2>递归实现</h2><pre><code>function int fibonacci_recursive(int n) {if (n<= 1) return n;return fibonacci_recursive(n-1) + fibonacci_recursive(n-2);}</code></pre></div><div class="syntax-section"><h2>迭代实现</h2><pre><code>function int fibonacci_iterative(int n) {if (n<= 1) return n;int a = 0, b = 1;for (int i = 2; i<= n; i++) {int temp = a + b;a = b;b = temp;}return b;}</code></pre></div><div class="syntax-section"><h2>完整程序</h2><pre><code>namespace Fibonacci;class Program {void Main() {Console.WriteLine("计算斐波那契数列");for (int i = 0; i<= 10; i++) {int result = fibonacci_iterative(i);Console.WriteLine("F(" + i + ") = " + result);}}function int fibonacci_iterative(int n) {if (n<= 1) return n;int a = 0, b = 1;for (int i = 2; i<= n; i++) {int temp = a + b;a = b;b = temp;}return b;}}</code></pre></div></div><div class="content-section" id="memory-safe-example"><h1>内存安全示例</h1><p>展示E#内存安全特性的实际应用。</p><div class="syntax-section"><h2>安全数据处理</h2><pre><code>function void process_data() {try {safe_array<int>numbers = safe_array<int>();// 安全添加数据for (int i = 0; i< 100; i++) {numbers.add(i * 2);}// 安全访问for (uint64 i = 0; i< numbers.size(); i++) {int val = numbers.get(i);Console.WriteLine("值: " + val);}// 自动清理 - 无需手动释放} catch (MemoryException e) {Console.WriteLine("内存错误: " + e.message);}}</code></pre></div></div><div class="content-section" id="system-calls"><h1>系统调用示例</h1><p>展示如何在E#中使用系统调用。</p><div class="syntax-section"><h2>文件操作</h2><pre><code>// Linux系统调用 - 文件读写namespace FileExample;class FileManager {function void write_file(string filename, string content) {asm {// 系统调用实现文件写入// 这里会生成适当的汇编代码}}function string read_file(string filename) {asm {// 系统调用实现文件读取// 返回文件内容}}}</code></pre></div></div><div class="content-section" id="stdlib-memory"><h1>标准库 - 内存管理</h1><p>E# 标准库提供的内存管理功能。</p><div class="syntax-section"><h2>内存管理函数</h2><pre><code>// 内存分配function ptr malloc(uint64 size);function void free(ptr p);function ptr memset(ptr dest, int value, uint64 size);function ptr memcpy(ptr dest, const ptr src, uint64 size);// 内存信息function uint64 get_total_memory();function uint64 get_free_memory();function MemoryStats get_memory_stats();</code></pre></div></div><div class="content-section" id="stdlib-string"><h1>标准库 - 字符串操作</h1><p>字符串处理的标准库函数。</p><div class="syntax-section"><h2>字符串操作函数</h2><pre><code>// 基本操作function uint64 strlen(string s);function int strcmp(string s1, string s2);function void strcpy(string dest, string src);function string strcat(string dest, string src);// 高级操作function string substring(string s, int start, int length);function int find(string haystack, string needle);function string replace(string s, string old, string new);function string to_upper(string s);function string to_lower(string s);</code></pre></div></div><div class="content-section" id="stdlib-io"><h1>标准库 - 输入输出</h1><p>标准输入输出函数。</p><div class="syntax-section"><h2>IO函数</h2><pre><code>// 基本IOfunction void print(string msg);function string read_line();function int read_int();function double read_double();// 文件IOclass File {static function File open(string filename, string mode);function void write(string content);function string read_all();function void close();};</code></pre></div></div></div><div class="navigation-buttons"><button class="nav-btn" id="prevBtn" onclick="navigateSection(-1)">上一页</button><button class="nav-btn" id="nextBtn" onclick="navigateSection(1)">下一页</button></div></div><script>let navigationOrder = []; let currentIndex = 0; let currentAnimation = null; document.addEventListener('DOMContentLoaded', function() { const treeItems = document.querySelectorAll('.tree-item[data-target]'); const toggles = document.querySelectorAll('.tree-toggle'); const contentOrder = [ 'overview', 'namespace', 'class', 'main', 'sections', 'basic-types', 'advanced-types', 'string-type', 'bool-type', 'ptr-type', 'var-int', 'var-string', 'var-double', 'var-bool', 'var-ptr', 'func-basic', 'func-asm', 'func-template', 'lambda', 'writeline', 'write', 'format', 'if-basic', 'if-else', 'if-elseif', 'for-loop', 'while-loop', 'do-while', 'memory-overview', 'memory-boundaries', 'memory-null', 'memory-management', 'memory-leaks', 'arrays', 'structs', 'generics', 'exceptions', 'concurrency', 'asm-basic', 'asm-volatile', 'asm-examples', 'hello-world', 'fibonacci', 'memory-safe-example', 'system-calls', 'stdlib-memory', 'stdlib-string', 'stdlib-io' ]; navigationOrder = contentOrder.map(target =>{ const element = document.querySelector(`[data-target="${target}"]`); return element ? { target, element } : null; }).filter(item =>item !== null); const firstItem = navigationOrder[0]; if (firstItem) { switchContent(firstItem.target, false); currentIndex = 0; } updateNavButtons(); toggles.forEach(toggle =>{ toggle.addEventListener('click', function(e) { e.stopPropagation(); const parent = this.parentElement; const targetId = parent.getAttribute('data-toggle'); const children = document.getElementById(targetId + '-children'); if (children) { children.classList.toggle('expanded'); this.textContent = children.classList.contains('expanded') ? '▼' : '▶'; } }); }); treeItems.forEach(item =>{ item.addEventListener('click', function() { const target = this.getAttribute('data-target'); switchContent(target); currentIndex = navigationOrder.findIndex(item =>item.target === target); updateNavButtons(); }); }); }); function switchContent(target, animate = true) { const oldActiveSection = document.querySelector('.content-section.active'); const newSection = document.getElementById(target); if (!newSection) { console.error('Target section not found:', target); return; } document.querySelectorAll('.tree-item').forEach(treeItem =>{ treeItem.classList.remove('active'); }); const navItem = document.querySelector(`[data-target="${target}"]`); if (navItem) { navItem.classList.add('active'); } if (animate && oldActiveSection && oldActiveSection !== newSection) { const allSections = Array.from(document.querySelectorAll('.content-section')); const oldIndex = allSections.indexOf(oldActiveSection); const newIndex = allSections.indexOf(newSection); const isNext = newIndex >oldIndex; allSections.forEach(section =>{ section.classList.remove('active', 'slide-up', 'slide-down'); }); oldActiveSection.classList.add(isNext ? 'slide-up' : 'slide-down'); oldActiveSection.classList.remove('active'); newSection.classList.add(isNext ? 'slide-down' : 'slide-up'); newSection.classList.remove('slide-up', 'slide-down'); newSection.offsetHeight; newSection.classList.add('active'); document.querySelector('.content').scrollTop = 0; } else { const allSections = document.querySelectorAll('.content-section'); allSections.forEach(section =>{ section.classList.remove('active', 'slide-up', 'slide-down'); }); newSection.classList.add('active'); document.querySelector('.content').scrollTop = 0; } } function navigateSection(direction) { const newIndex = currentIndex + direction; if (newIndex >= 0 && newIndex< navigationOrder.length) { currentIndex = newIndex; const target = navigationOrder[currentIndex].target; switchContent(target, true); updateNavButtons(); const navItem = navigationOrder[currentIndex].element; let parent = navItem.parentElement; while (parent && parent !== document.querySelector('.sidebar')) { if (parent.classList.contains('tree-children')) { parent.classList.add('expanded'); const toggle = parent.previousElementSibling?.querySelector('.tree-toggle'); if (toggle) { toggle.textContent = '▼'; } } parent = parent.parentElement; } } } function updateNavButtons() { const prevBtn = document.getElementById('prevBtn'); const nextBtn = document.getElementById('nextBtn'); if (prevBtn) prevBtn.disabled = currentIndex<= 0; if (nextBtn) nextBtn.disabled = currentIndex >= navigationOrder.length - 1; } function initSinglePageScroll() { const content = document.querySelector('.content'); const sections = document.querySelectorAll('.content-section'); const treeItems = document.querySelectorAll('.tree-item'); const style = document.createElement('style'); style.textContent = ` .blur-transition { filter: blur(12px) brightness(0.95); opacity: 0.5; transform: translateY(30px) scale(0.98); transition: filter 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); } .content-container { transition: filter 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); } `; document.head.appendChild(style); function mergeAllContent() { const mainContainer = document.createElement('div'); mainContainer.className = 'single-page-content'; mainContainer.style.padding = '20px 0'; const allSections = Array.from(sections); allSections.forEach((section, index) =>{ const originalHTML = section.innerHTML; const sectionWrapper = document.createElement('div'); sectionWrapper.className = 'chapter-section'; sectionWrapper.setAttribute('data-chapter', section.id); sectionWrapper.style.marginBottom = '60px'; sectionWrapper.style.padding = '20px'; sectionWrapper.style.borderBottom = '1px solid #eee'; const contentDiv = document.createElement('div'); contentDiv.className = 'content-section active'; contentDiv.id = section.id; contentDiv.style.display = 'block'; contentDiv.style.opacity = '1'; contentDiv.style.transform = 'none'; contentDiv.style.filter = 'none'; contentDiv.innerHTML = originalHTML; const title = contentDiv.querySelector('h1, h2, h3'); if (title) { title.style.fontSize = '2em'; title.style.marginBottom = '20px'; title.style.color = '#1976d2'; title.style.borderBottom = '2px solid #e3f2fd'; title.style.paddingBottom = '10px'; } sectionWrapper.appendChild(contentDiv); mainContainer.appendChild(sectionWrapper); }); content.innerHTML = ''; content.appendChild(mainContainer); return mainContainer; } const chapterMap = []; function buildChapterMap() { const chapterSections = document.querySelectorAll('.chapter-section'); chapterSections.forEach((section, index) =>{ const id = section.getAttribute('data-chapter'); const navItem = document.querySelector(`[data-target="${id}"]`); if (navItem) { chapterMap.push({ id: id, element: section, navItem: navItem, index: index }); } }); } function updateActiveChapter() { const scrollTop = content.scrollTop; const contentHeight = content.clientHeight; let activeChapter = null; let minDistance = Infinity; chapterMap.forEach(chapter =>{ const rect = chapter.element.getBoundingClientRect(); const contentRect = content.getBoundingClientRect(); const relativeTop = rect.top - contentRect.top + scrollTop; const distance = Math.abs(relativeTop - scrollTop - contentHeight/3); if (distance< minDistance) { minDistance = distance; activeChapter = chapter; } }); if (activeChapter) { const sidebar = document.querySelector('.sidebar'); const currentSidebarScroll = sidebar.scrollTop; treeItems.forEach(item =>item.classList.remove('active')); activeChapter.navItem.classList.add('active'); sidebar.scrollTop = currentSidebarScroll; updateNavButtons(activeChapter.index, chapterMap.length - 1); let parent = activeChapter.navItem.parentElement; while (parent && parent !== document.querySelector('.sidebar')) { if (parent.classList.contains('tree-children')) { parent.classList.add('expanded'); const toggle = parent.previousElementSibling?.querySelector('.tree-toggle'); if (toggle) { toggle.textContent = '▼'; } } parent = parent.parentElement; } const activeItem = activeChapter.navItem; const itemRect = activeItem.getBoundingClientRect(); const sidebarRect = sidebar.getBoundingClientRect(); if (itemRect.top< sidebarRect.top || itemRect.bottom >sidebarRect.bottom) { const scrollOffset = itemRect.top - sidebarRect.top - 100; sidebar.scrollTop += scrollOffset; } } } function handleNavClick() { treeItems.forEach(item =>{ item.addEventListener('click', function(e) { e.preventDefault(); const target = this.getAttribute('data-target'); const chapter = chapterMap.find(c =>c.id === target); if (chapter) { const sidebar = document.querySelector('.sidebar'); const currentSidebarScroll = sidebar.scrollTop; const currentActive = document.querySelector('.tree-item.active'); const currentTarget = currentActive?.getAttribute('data-target'); const currentIndex = chapterMap.findIndex(c =>c.id === currentTarget); const targetIndex = chapterMap.findIndex(c =>c.id === target); const isAdjacent = Math.abs(currentIndex - targetIndex)<= 1; const isFarJump = !isAdjacent && currentIndex !== -1 && Math.abs(currentIndex - targetIndex) >2; if (isFarJump) { content.classList.add('blur-transition'); const targetOffsetTop = chapter.element.offsetTop; content.scrollTo({ top: targetOffsetTop - 80, behavior: 'smooth' }); setTimeout(() =>{ content.classList.remove('blur-transition'); }, 400); } else { const targetOffsetTop = chapter.element.offsetTop; content.scrollTo({ top: targetOffsetTop - 80, behavior: 'smooth' }); } setTimeout(() =>{ sidebar.scrollTop = currentSidebarScroll; }, 50); } }); }); } window.navigateSection = function(direction) { const currentActive = document.querySelector('.tree-item.active'); if (!currentActive) return; const currentTarget = currentActive.getAttribute('data-target'); const currentIndex = chapterMap.findIndex(c =>c.id === currentTarget); const newIndex = currentIndex + direction; if (newIndex >= 0 && newIndex< chapterMap.length) { const newChapter = chapterMap[newIndex]; const targetOffsetTop = newChapter.element.offsetTop; content.scrollTo({ top: targetOffsetTop - 80, behavior: 'smooth' }); } }; function updateNavButtons(currentIdx, maxIdx) { const prevBtn = document.getElementById('prevBtn'); const nextBtn = document.getElementById('nextBtn'); if (prevBtn) prevBtn.disabled = currentIdx<= 0; if (nextBtn) nextBtn.disabled = currentIdx >= maxIdx; } mergeAllContent(); buildChapterMap(); handleNavClick(); content.addEventListener('scroll', updateActiveChapter); setTimeout(updateActiveChapter, 100); } function initMobileSidebar() { const sidebar = document.querySelector('.sidebar'); const content = document.querySelector('.content'); const mobileToggle = document.createElement('button'); mobileToggle.className = 'mobile-toggle'; mobileToggle.innerHTML = '☰'; mobileToggle.onclick = toggleSidebar; const overlay = document.createElement('div'); overlay.className = 'overlay'; overlay.onclick = closeSidebar; document.body.appendChild(mobileToggle); document.body.appendChild(overlay); function toggleSidebar() { sidebar.classList.toggle('open'); overlay.classList.toggle('show'); } function closeSidebar() { sidebar.classList.remove('open'); overlay.classList.remove('show'); } window.addEventListener('resize', function() { if (window.innerWidth >768) { closeSidebar(); } }); document.querySelectorAll('.tree-item').forEach(item =>{ item.addEventListener('click', function() { if (window.innerWidth<= 768) { closeSidebar(); } }); }); } document.addEventListener('DOMContentLoaded', function() { initMobileSidebar(); setTimeout(initSinglePageScroll, 200); });</script></body></html>